import { Sandbox } from '@e2b/code-interpreter';

interface E2BSession {
  id: string;
  status: string;
}

export class E2BService {
  private apiKey: string;

  constructor() {
    this.apiKey = process.env.E2B_API_KEY || process.env.E2B_KEY || "";
  }

  async createSession(): Promise<E2BSession> {
    if (!this.apiKey) {
      console.log("E2B API key not configured, using mock session");
      return {
        id: `mock-session-${Date.now()}`,
        status: "running"
      };
    }

    try {
      const sandbox = await Sandbox.create({ 
        apiKey: this.apiKey,
        template: 'nodejs' 
      });

      console.log(`E2B sandbox created: ${sandbox.sandboxId}`);

      return {
        id: sandbox.sandboxId,
        status: "running"
      };
    } catch (error) {
      console.error("E2B session creation error:", error);
      // Return mock session for development
      return {
        id: `mock-session-${Date.now()}`,
        status: "running"
      };
    }
  }

  async deployProject(sessionId: string, files: Array<{ path: string; content: string }>): Promise<string> {
    try {
      console.log(`Deploying project to E2B session: ${sessionId}`);
      console.log(`Files to deploy: ${files.map(f => f.path).join(", ")}`);

      if (!this.apiKey || sessionId.startsWith('mock-session-')) {
        // Return mock URL for development when E2B is not configured
        return `https://${sessionId}.e2b.dev`;
      }

      const sandbox = await Sandbox.create({ 
        apiKey: this.apiKey,
        sandboxId: sessionId 
      });

      // Upload files to E2B sandbox
      for (const file of files) {
        await sandbox.files.write(file.path, file.content);
        console.log(`Uploaded file: ${file.path}`);
      }

      // Check if this is a Next.js project
      const isNextJs = files.some(f => f.path.includes('app/page.tsx') || f.path.includes('pages/'));
      const hasPackageJson = files.some(f => f.path === 'package.json');

      if (isNextJs) {
        // Check if we need to create essential Next.js files
        const hasLayoutFile = files.some(f => f.path === 'app/layout.tsx');
        
        if (!hasPackageJson) {
          // Create a minimal Next.js package.json with only essential dependencies
          console.log('Creating minimal Next.js package.json...');
          const nextPackageJson = {
            "name": "generated-nextjs-app",
            "version": "0.1.0",
            "private": true,
            "scripts": {
              "dev": "HOSTNAME=0.0.0.0 PORT=3000 next dev --hostname 0.0.0.0 --port 3000",
              "build": "next build", 
              "start": "HOSTNAME=0.0.0.0 PORT=3000 next start --hostname 0.0.0.0 --port 3000"
            },
            "dependencies": {
              "next": "^14.0.0",
              "react": "^18.0.0",
              "react-dom": "^18.0.0",
              "@types/node": "^20.0.0",
              "@types/react": "^18.0.0",
              "@types/react-dom": "^18.0.0",
              "typescript": "^5.0.0"
            }
          };
          await sandbox.files.write('package.json', JSON.stringify(nextPackageJson, null, 2));
        }
        
        // Create next.config.js with proper host configuration for E2B
        const nextConfig = `/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true
  },
  // Disable host checks for E2B
  devIndicators: {
    buildActivity: false
  },
  // Allow all hosts in development
  async rewrites() {
    return []
  },
  // Disable strict host checking
  typescript: {
    ignoreBuildErrors: true
  },
  eslint: {
    ignoreDuringBuilds: true
  }
}

module.exports = nextConfig`;
        await sandbox.files.write('next.config.js', nextConfig);
        
        // Create required layout.tsx if missing
        if (!hasLayoutFile) {
          console.log('Creating app/layout.tsx...');
          const layoutContent = `import './globals.css'

export const metadata = {
  title: 'Generated App',
  description: 'Generated by AI',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}`;
          await sandbox.files.write('app/layout.tsx', layoutContent);
        }
        
        // Create TypeScript config
        const tsConfig = {
          "compilerOptions": {
            "target": "es5",
            "lib": ["dom", "dom.iterable", "es6"],
            "allowJs": true,
            "skipLibCheck": true,
            "strict": true,
            "noEmit": true,
            "esModuleInterop": true,
            "module": "esnext",
            "moduleResolution": "bundler",
            "resolveJsonModule": true,
            "isolatedModules": true,
            "jsx": "preserve",
            "incremental": true,
            "plugins": [{ "name": "next" }],
            "baseUrl": ".",
            "paths": { "@/*": ["./*"] }
          },
          "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
          "exclude": ["node_modules"]
        };
        await sandbox.files.write('tsconfig.json', JSON.stringify(tsConfig, null, 2));
        
        // Create next-env.d.ts
        await sandbox.files.write('next-env.d.ts', '/// <reference types="next" />\n/// <reference types="next/image-types/global" />');
      }

      // Install dependencies with timeout
      if (hasPackageJson || isNextJs) {
        console.log('Installing dependencies...');
        try {
          const installResult = await sandbox.commands.run('npm install --no-audit --no-fund', {
            timeoutMs: 120000 // 2 minute timeout
          });
          console.log('npm install result:', installResult.stdout);
          
          if (installResult.stderr && installResult.stderr.includes('error')) {
            console.log('npm install errors:', installResult.stderr);
          }
        } catch (error) {
          console.log('npm install timeout or error, trying alternative approach...');
          // Fallback to serve if npm install fails
          const serveCommand = 'npx serve -s . -p 3000 -H 0.0.0.0';
          sandbox.commands.run(serveCommand, { timeoutMs: 60000 }).catch(err => {
            console.log('Serve command error:', err.message);
          });
          await new Promise(resolve => setTimeout(resolve, 5000));
          return `https://${sandbox.sandboxId}.e2b.dev`;
        }
      }

      // Start the development server with timeout
      console.log('Starting development server...');
      let startCommand;
      
      if (isNextJs) {
        // Use simple Next.js dev command
        startCommand = 'npm run dev';
      } else if (hasPackageJson) {
        startCommand = 'npm run dev';
      } else {
        startCommand = 'npx serve -s . -p 3000 -H 0.0.0.0';
      }

      // Start server in background with timeout
      sandbox.commands.run(startCommand, { 
        timeoutMs: 180000 // 3 minute timeout
      }).catch(error => {
        console.log('Server start command completed or errored:', error.message);
      });

      // Wait longer for server to start
      await new Promise(resolve => setTimeout(resolve, 8000));

      // Return the preview URL - E2B provides this automatically
      return `https://${sandbox.sandboxId}.e2b.dev`;
    } catch (error) {
      console.error("E2B deployment error:", error);
      throw new Error(`Failed to deploy project: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }

  async getProjectFiles(sessionId: string): Promise<Array<{ path: string; content: string }>> {
    try {
      if (!this.apiKey || sessionId.startsWith('mock-session-')) {
        return [];
      }

      const sandbox = await Sandbox.create({ 
        apiKey: this.apiKey,
        sandboxId: sessionId 
      });

      // List all files in the project directory
      const result = await sandbox.commands.run('find . -type f -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.json" -o -name "*.css" -o -name "*.md" | head -20');
      const filePaths = result.stdout.split('\n').filter(path => path.trim() && !path.includes('node_modules') && !path.includes('.git'));

      const files = [];
      for (const filePath of filePaths) {
        try {
          const content = await sandbox.files.read(filePath.replace('./', ''));
          files.push({
            path: filePath.replace('./', ''),
            content: content
          });
        } catch (error) {
          console.log(`Could not read file ${filePath}:`, error);
        }
      }

      return files;
    } catch (error) {
      console.error("Error getting project files:", error);
      return [];
    }
  }

  async destroySession(sessionId: string): Promise<void> {
    try {
      console.log(`Destroying E2B session: ${sessionId}`);

      if (!this.apiKey || sessionId.startsWith('mock-session-')) {
        console.log('Mock session, nothing to destroy');
        return;
      }

      const sandbox = await Sandbox.create({ 
        apiKey: this.apiKey,
        sandboxId: sessionId 
      });

      await sandbox.close();
      console.log(`E2B session ${sessionId} destroyed successfully`);
    } catch (error) {
      console.error("E2B session destruction error:", error);
    }
  }
}

export const e2bService = new E2BService();